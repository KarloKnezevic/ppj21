options {
  JDK_VERSION = "1.5";
  VISITOR=true;
  MULTI=true;
  NODE_PREFIX="AST";
}
 
PARSER_BEGIN(MiniJava) 
package hr.fer.ppj21.labos.parser;
import java.io.InputStream;
public class MiniJava {
}
PARSER_END(MiniJava)

TOKEN :
{
< INT: "int">
| < INT_ARRAY: <INT><LBRACKET><RBRACKET> >
| < BOOLEAN: "boolean">
| < CLASS: "class">
| < THIS: "this">
| < EXTENDS: "extends">
| < PUBLIC: "public">
| < STATIC: "static">
| < VOID: "void">
| < RETURN: "return">
| < MAIN: "main">
| < IF: "if">
| < ELSE: "else">
| < WHILE: "while">
| < PRINT: "System.out.println">
| < NEW: "new">
| < STRING: "String">
| < LENGTH: "length">
}

TOKEN :
{
< ID: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER: ["_","a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
}

TOKEN :
{
< LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

SKIP :
{
" "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
< ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < NOT: "!" >
| < EQ: "==" >
| < OR: "||" >
| < AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
}

SPECIAL_TOKEN :
{
<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
|<FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
|<MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN :
{
< INTEGER_LITERAL: "0" | ["1"-"9"] (["0"-"9"])*>
| < BOOLEAN_LITERAL: ("true"|"false")>
}

SimpleNode Start() : {}
{
Program()
{ return jjtThis; }
}
void Program() : {}
{
MainClass()( LOOKAHEAD(DerivedClass())
DerivedClass() | Class() )*
}
void MainClass() : {}
{
<CLASS> Identifier() <LBRACE>
<PUBLIC> <STATIC> <VOID> <MAIN>
<LPAREN> <STRING> <LBRACKET>
<RBRACKET> <ID> <RPAREN> <LBRACE>
MainMethod() <RBRACE> <RBRACE>
}

void MainMethod():{}
{
(MethodBody())*
}
void Class() : {}
{
<CLASS> Identifier() <LBRACE> ( Body()
)* <RBRACE>
}
void DerivedClass() : {}
{
<CLASS> Identifier() <EXTENDS>
Identifier() <LBRACE> (Body() )* <RBRACE>
}
void Body() : {}
{
VarDecl()
| MethodDecl()
}
void VarDecl() : {}
{
Type() Identifier() [<ASSIGN> Exp()]
<SEMICOLON>
}
void MethodDecl() : {}
{
<PUBLIC> Type() Identifier() <LPAREN>
FormalList() <RPAREN> <LBRACE>
MethodBoodyBlock() <RETURN> Exp()
<SEMICOLON> <RBRACE>
}
void MethodBoodyBlock():{}
{
(MethodBody())*
}

void MethodBody() : {}
{
LOOKAHEAD(VarDecl()) VarDecl()
| Statment()
}
void FormalList() : {}
{
[ Parameter() ( <COMMA> Parameter() )* ]
}
void Parameter() : {}
{
Type() Identifier()
}
void Type() : {}
{
BooleanType()
| Identifier()
| LOOKAHEAD(IntArrayType())
IntArrayType()
| IntegerType()
}
void Object() : {}
{
This()
| Identifier()
|  NewObject()
}
void Statment() : {}
{
LOOKAHEAD(IfElse()) IfElse()
| If()
| While()
| Print()
| Assignment()
| <LBRACE> (Statment())* <RBRACE>
}
void UnaryAssignment() : {}
{
[ LOOKAHEAD(2) Object() <DOT> ]
Identifier() <ASSIGN> Exp()
}
void ArrayAssignment() : {}
{
[ LOOKAHEAD(2) Object() <DOT> ]
Identifier()<LBRACKET> Exp() <RBRACKET>
<ASSIGN> Exp()
}
void Assignment() : {}
{
(LOOKAHEAD(
ArrayAssignment())ArrayAssignment() |
UnaryAssignment()) <SEMICOLON>
}

void If() : {}
{
<IF> <LPAREN> Exp() <RPAREN>
Statment()
}
void IfElse() : {}
{
<IF> <LPAREN> Exp() <RPAREN>
Statment() <ELSE> Statment()
}
void Print() : {}
{
<PRINT> <LPAREN> Exp() <RPAREN>
<SEMICOLON>
}
void While() : {}
{
<WHILE> <LPAREN> Exp() <RPAREN>
Statment()
}
void Exp() : {}
{
  LOOKAHEAD(OrExp())
OrExp()
|  NewObject()
}
void OrExp() #void : {}
{
AndExp() ( Or() AndExp() )*
}
void AndExp() #void : {}
{
NotExp() ( And() NotExp())*
}
void NotExp() #void : {}
{
[ Not() ] LGEExp()
}
void LGEExp() #void : {}
{
AdditiveExpression()( (
GreaterThan() | LessThan() | Equal()
) AdditiveExpression())*
}
void Integer() : {
  Token t;
}
{
	t=<INTEGER_LITERAL>
  {
    jjtThis.setValue(t.image);
  }
}
void IntegerType() : {}
{
<INT>
}

void AdditiveExpression() #void : {}
{
MultiplicativeExpression() ( (
Plus() | Minus() )
MultiplicativeExpression() )*
}
void MultiplicativeExpression() #void : {}
{
UnaryExpression() ( ( Star() |
Slash() ) UnaryExpression() )*
}
void UnaryExpression() #void : {}
{
[ Minus() ] Element()
}
void Element() : {}
{
Integer()
| Boolean()
| IdentifierExp()
| <LPAREN> Exp() <RPAREN>
}
void IdentifierExp() : {}
{
LOOKAHEAD( Identifier() <DOT>
Length() ) Identifier() <DOT> Length()
|
[ LOOKAHEAD(Object() <DOT>) Object()
<DOT> ] Identifier() [ <LBRACKET>
Exp() <RBRACKET>
| <DOT> Length()
| <LPAREN> ExpList() <RPAREN>
]
}
void NewObject() : {}
{
<NEW> (IntegerType() <LBRACKET>
Exp() <RBRACKET> | Identifier() <LPAREN>
<RPAREN> )
}
void ExpList() : {}
{
[ Exp() ( <COMMA> Exp() )* ]
}
void Classs() : {}
{
<CLASS>
}
void Identifier() : {
	Token t;
}
{
	t=<ID>
  {
    jjtThis.setValue(t.image);
  }
}

void IntArrayType() : {}
{
<INT_ARRAY>
}
void BooleanType() : {}
{
<BOOLEAN>
}
void Boolean() : {}
{
<BOOLEAN_LITERAL>
}
void Not() : {}
{
<NOT>
}
void Or() : {}
{
<OR>
}
void And() : {}
{
<AND>
}
void Length() : {}
{
<LENGTH>
}

void Star() : {}
{
<STAR>
}
void Plus() : {}
{
<PLUS>
}
void Minus() : {}
{
<MINUS>
}
void Assign() : {}
{
<ASSIGN>
}
void Slash() : {}
{
<SLASH>
}
void Equal() : {}
{
<EQ>
}
void LessThan() : {}
{
<LT>
}
void GreaterThan() : {}
{
<GT>
}
void This() : {}
{
<THIS>
}