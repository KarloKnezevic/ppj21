int getSize(String constructName) return construct's size
String getType(String identifier) return identifier's type
Label getNextLabel() return a label
Stm add(Stm, Stm) return Seq(Stm, Stm)
Stm push(Expr e) push e on stack and dec SP
Stm pop() inc SP
Expr not (Expr)
Expr getThis() getLocal("this")
Expr getLocal(String varName) return Mem[fp + getOffset(varName+"@"+curMethod+"@"+curClass)]
Expr getField(String varName) return Mem[getThis + getOffset(varName+"@"+curClass)]
//Allocates size WORDS and saves its address in AR
Stm allocate(Expr size, boolean array)
		new Move(AR, HP);
		Mem[sp] <- size
		if (array) {
			Mem[hp] <- Mem[sp]
		 	hp <- hp + WORDSIZE
		}
		while (Mem[sp] > 0) {
			Mem[hp] <- 0
		 	hp <- hp + WORDSIZE
		 	Mem[sp] <- Mem[sp] - 1;
		}
Stm visit(MainClass)
	Label "MAIN"
	HP <- 2
	FP <- LAST_STACK - WORDSIZE
	SP <- FP
	visit(statement)
	Label "DONE"
Stm visit(ClassDecl)
	curClass = className
	for all methods
		result.add(visit(method))
	curClass = ""
Stm visit(MethodDecl)
	curMethod = methodName
	Label className + "_" + methodName
		(+ for all descenders, Label name + "_" +methodName)
	FP <- SP
	for all locals
		push(0)
	for all statements
		visit(statement)
	DR <- return value
	for all locals
		pop
	AR <- ret adr
	FP <- old FP
	curMethod = ""
Stm visit(Statement)
	if {Statement*}
		visit all statements
	if (if Exp Stm1 else Stm2)
		ifthenelse(Exp, Stm1, Stm2)
	if (while Exp Stm)
		while(Exp, Stm)
	if (ID = Exp)
		Move(visit(ID), visit(Exp))
	if (ID[Exp1] = Exp2)
		Move(arrayIndex(Exp1), Exp2)
Expr visit Factor
	Expr object;
	Stm allocation;
	if (Atom)
		object = visit(Atom)
	if (new ID())
		allocation = allocate(ID.getSize(), false)
		object = AR;
		curType = ID.getType()
	if (new int[Exp])
		allocation = allocate(Exp, true)
		object = AR
		curType = array
	Stm s = allocation
	for all methodCall mc
		Stm check = ifThen(object=0, RuntimeError("NullPointer"))
		if (.length)
			curType = int
			s.add(check)
			object = Mem[object]
		if ((Exp))
			object = arrayIndex(object, Exp).exp
			s.add(arrayIndex(object, Exp).stm)
		if (.ID(Exps))
			find all arguments
			methodAddress = curType + IDname
			s.add 		check
					put arguments
					push object //as "this"
					push ret adr
					push old fp
					Jump(methodAddress)
					pop ret adr, old fp, this
					pop all arguments
			object = DR
			curType = find return type of method
	if (s not null)
		object = ESeq(s, object)
	if (not operator present and there are odd number of nots)
		object = not(object)
	return object
Expr visit(Atom)
	if (this)
		curType = curClass
		return getThis
	if ((Expr))
		return Expr
	if (ID)
		return visit(ID)
	if (INT/TRUE/FALSE)
		return ...
Expr visit(ID)
	name = ID.name
	if (name is a local)
		curType = getType(curClass + ":" + curMethod + ":" + name)
		return getLocal(name)
	else if (name is a field)
		curType = getType(curClass + ":" + name)
		return getField(name)
Stm ifThenElse(Exp, Stm1, Stm2)
	CJump(Exp, t, f)
	Label t
	Stm1
	Jump j
	Label f
	Stm2
	Label j
Stm ifThen(Exp, Stm)
	CJump(Exp, t, d)
	Label t
	Stm1
	Label d
Stm while(Exp, Stm)
	Label c
	CJump(Exp, b, d)
	Label b
	Stm
	Jump c
	Label d
Expr arrayIndex(Exp a, Exp index)
	Stm s = 	TR <- index+1
			ifThen(a=0, RuntimeError("NullPointer"))
			ifThen(Mem[a] < TR, RuntimeError("IndexOutOfBounds"))
			ifThen(TR < 1, RuntimeError("IndexOutOfBounds"))
	return ESeq(s, Mem[a + TR*WORDSIZE] )